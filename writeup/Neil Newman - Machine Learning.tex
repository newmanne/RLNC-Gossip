\documentclass{article} % For LaTeX2e
\usepackage{nips14submit_e,times}
\usepackage{hyperref}
\usepackage{url}
\usepackage{graphicx}
\usepackage[super]{nth}
\usepackage{todonotes}
\usepackage{amsfonts}

%\documentstyle[nips14submit_09,times,art10]{article} % For LaTeX 2.09

\title{CPSC 536N Project: Gossip Protocols with Random Linear Network Coding}
\author{
Neil~Newman\\
81435142\\
Department of Computer Science\\
University of British Columbia\\
Vancouver, BC V6T 1Z4 \\
\texttt{newmanne@cs.ubc.ca}
}
\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\def\numNodes{\textit{n}\,}
\def\graph{\textit{G(t)}\,}
\def\graphtime{\textit{t}\,}
\def\numMessages{\textit{k}\,}
\def\RLNC{\textit{RLNC}\,}
\def\fieldSize{\textit{q}\,}

\nipsfinalcopy % Uncomment for camera-ready version

\begin{document}

\maketitle

\section{Introduction}
''The goal of gossip protocols is to make all messages known to all nodes in the network using as little time as possible (in expectation and with high probability).`` Random Linear Network Coding (\RLNC). Structured multi-cast relies on a known, non-changing network topology. 

\subsection{Model of Network and Communication}
We will use the model from \cite{haeupler2011analyzing}, which is as follows: There are \numNodes nodes in the network. A network is a graph \graph that can vary with time \graphtime and is either directed or undirected. An edge in \graph from any two nodes \textit{a} and \textit{b} represents a link through which communication can take place in round \graphtime; if the edge is directed it means that communication can only occur in the direction of the edge. We will assume that \graph is connected at every \graphtime, however this requirement can be weakened. 

\subsection{Message structure}
There are \numMessages distributed over the network (see \ref{subsec:startingconditions} for details on the ways in which we consider the messages to be distributed). 

\subsection{Additional assumptions}
Packets are never dropped. All packets have the same size. 

\subsection{Modes of communication}
We allow the following four modes of communication:
\begin{itemize}
\item \texttt{BROADCAST} A node sends to all of its neighbours
\item \texttt{PUSH} A node sends to one neighbour chosen uniformly at random
\item \texttt{PULL} A node chooses a neighbour uniformly at random and receives a message from the neighbour
\item \texttt{EXCHANGE} A node chooses a neighbour uniformly at random and they each send each send each other a message
\end{itemize}
The choice of what packet to send is never conditioned on the who will receive the packet.

\subsection{Timing models}
Synchronous: every node is activated every round. Discrete.
Asynchrounous: TODO:

\subsection{Starting conditions}\label{subsec:startingconditions}
We consider the following starting conditions:
\begin{itemize}
\item \texttt{DISTRIBUTED} Each node knows a single, unique message
\item \texttt{SINGLE} A single node knows every message, other nodes know nothing
\end{itemize}

\subsection{Graph types}
\begin{itemize}
\item \texttt{COMPLETE} Every node is connected to every other node
\item \texttt{ADVERSERIAL} sadfa\todo{stuff}
\end{itemize}

\subsection{RLNC Algorithm}
\paragraph{Preliminaries}
Packets are vectors over a finite field $\mathbb{F}_{\fieldSize}$, where the size of the field, \fieldSize, is an arbitrary prime or prime power. There are \numMessages messages, $\vec{m_{1}}$ that are vectors from $\mathbb{F}_{\fieldSize}^{l}$. Packets are of the form ($\vec{\mu}, \vec{m}$), where $\vec{m} = \sum_{i=1}^{\numMessages} \mu_i\vec{m_i} \in \mathbb{F}_{\fieldSize}^{l}$ and $\vec{\mu} = (\mu_1,...,\mu_k) \in \mathbb{F}_{\fieldSize}^{\numMessages}$ is the coefficient vector. Note that if a node ever knows enough coefficient vectors such that the span of these vectors is $\mathbb{F}_{\fieldSize}^{\numMessages}$ then Gaussian elimination can be used to reconstruct all of the messages. Therefore, a minium of \numMessages packets with linearly independent coefficients are needed.
\paragraph{Algorithm}
Every node \textit{v} keeps a subspace $X_v$ that is the span of all of the coefficient vectors it currently knows. When a packet needs to be chosen to send, a node chooses a packet uniformly at random from $X_v$. When a packet is received, $X_v$ is recomputed. If $X_v = \mathbb{F}_{\fieldSize}^{\numMessages}$ then a node can decode messages. When this is true for every node, the algorithm is considered to have stopped. 


\subsection{Summary of theoretical results}

\subsection{Practical details}
Experiments were performed using \textit{python}. The \textit{networkx} library was used to generate graphs.

\subsection{Results}
\begin{figure}
\centering
\missingfigure{Runtimes}
\label{fig:runtimes}
\end{figure} 

\subsection{Discussion}

\subsection{Conclusions}

\bibliography{nips}

%\paragraph{}
%I propose doing my project on the topic of \emph{Gossip / Epidemic Protocols}. These protocols are used to spread information that is initially known only to some nodes throughout a network, and they are especially well suited to cases where the global network structure is unknown or dynamic. The algorithms resemble the way that humans spread rumors or how a virus spreads. Every round, a series of pairwise interactions occur in which a node chooses another node at random and exchanges information with it. These methods can be applied to database replication \cite{demers1987epidemic}.
%\paragraph{}
%One issue with gossip protocols is that if the goal is to spread multiple messages in parallel, nodes need to choose which information they send in each interaction, and it is possible for some messages to become widely spread while others remain rare, so that the stopping time (when everyone knows everything) is dominated by the time it takes to propogate rare messages. This can be circumvented by using gossip protocol based on \emph{Random Linear Network Coding} (RLNC). In this protocol, nodes exchange messages which are random linear combinations of the original messages, with the coefficients chosen from a Galois field. The original messages can be recovered using Gaussian elimination once enough linearly independent coefficient vectors have been received.
%\paragraph{}
%For my project, I plan to read \emph{Analyzing network coding gossip made easy} and \emph{Epidemic algorithms for replicated database maintenance}. I plan to implement the gossip algorithm with RLNC and perform experiments to measure the stopping time. I will investigate the performance on static graphs vs dynamic graphs, on different starting knowledge configurations, and I will investigate the impact of the different ways in which nodes can connect with each other: broadcasting, pushing, pulling, and exchanging. I will compare my results with the theoretical stopping times given in \cite{haeupler2011analyzing}.



\end{document}